{"ast":null,"code":"/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n/*namespace com.google.zxing.qrcode.encoder {*/\n\n\nimport EncodeHintType from '../../EncodeHintType';\nimport BitArray from '../../common/BitArray';\nimport CharacterSetECI from '../../common/CharacterSetECI';\nimport GenericGF from '../../common/reedsolomon/GenericGF';\nimport ReedSolomonEncoder from '../../common/reedsolomon/ReedSolomonEncoder';\nimport Mode from '../decoder/Mode';\nimport Version from '../decoder/Version';\nimport MaskUtil from './MaskUtil';\nimport ByteMatrix from './ByteMatrix';\nimport QRCode from './QRCode';\nimport MatrixUtil from './MatrixUtil';\nimport StringEncoding from '../../util/StringEncoding';\nimport BlockPair from './BlockPair';\nimport WriterException from '../../WriterException';\n/*import java.io.UnsupportedEncodingException;*/\n\n/*import java.util.ArrayList;*/\n\n/*import java.util.Collection;*/\n\n/*import java.util.Map;*/\n\n/**\n * @author satorux@google.com (Satoru Takabayashi) - creator\n * @author dswitkin@google.com (Daniel Switkin) - ported from C++\n */\n\nvar Encoder = function () {\n  // TYPESCRIPTPORT: changed to UTF8, the default for js\n  function Encoder() {} // The mask penalty calculation is complicated.  See Table 21 of JISX0510:2004 (p.45) for details.\n  // Basically it applies four rules and summate all penalties.\n\n\n  Encoder.calculateMaskPenalty = function (matrix) {\n    return MaskUtil.applyMaskPenaltyRule1(matrix) + MaskUtil.applyMaskPenaltyRule2(matrix) + MaskUtil.applyMaskPenaltyRule3(matrix) + MaskUtil.applyMaskPenaltyRule4(matrix);\n  };\n  /**\n   * @param content text to encode\n   * @param ecLevel error correction level to use\n   * @return {@link QRCode} representing the encoded QR code\n   * @throws WriterException if encoding can't succeed, because of for example invalid content\n   *   or configuration\n   */\n  // public static encode(content: string, ecLevel: ErrorCorrectionLevel): QRCode /*throws WriterException*/ {\n  //   return encode(content, ecLevel, null)\n  // }\n\n\n  Encoder.encode = function (content, ecLevel, hints) {\n    if (hints === void 0) {\n      hints = null;\n    } // Determine what character encoding has been specified by the caller, if any\n\n\n    var encoding = Encoder.DEFAULT_BYTE_MODE_ENCODING;\n    var hasEncodingHint = hints !== null && undefined !== hints.get(EncodeHintType.CHARACTER_SET);\n\n    if (hasEncodingHint) {\n      encoding = hints.get(EncodeHintType.CHARACTER_SET).toString();\n    } // Pick an encoding mode appropriate for the content. Note that this will not attempt to use\n    // multiple modes / segments even if that were more efficient. Twould be nice.\n\n\n    var mode = this.chooseMode(content, encoding); // This will store the header information, like mode and\n    // length, as well as \"header\" segments like an ECI segment.\n\n    var headerBits = new BitArray(); // Append ECI segment if applicable\n\n    if (mode === Mode.BYTE && (hasEncodingHint || Encoder.DEFAULT_BYTE_MODE_ENCODING !== encoding)) {\n      var eci = CharacterSetECI.getCharacterSetECIByName(encoding);\n\n      if (eci !== undefined) {\n        this.appendECI(eci, headerBits);\n      }\n    } // (With ECI in place,) Write the mode marker\n\n\n    this.appendModeInfo(mode, headerBits); // Collect data within the main segment, separately, to count its size if needed. Don't add it to\n    // main payload yet.\n\n    var dataBits = new BitArray();\n    this.appendBytes(content, mode, dataBits, encoding);\n    var version;\n\n    if (hints !== null && undefined !== hints.get(EncodeHintType.QR_VERSION)) {\n      var versionNumber = Number.parseInt(hints.get(EncodeHintType.QR_VERSION).toString(), 10);\n      version = Version.getVersionForNumber(versionNumber);\n      var bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, version);\n\n      if (!this.willFit(bitsNeeded, version, ecLevel)) {\n        throw new WriterException('Data too big for requested version');\n      }\n    } else {\n      version = this.recommendVersion(ecLevel, mode, headerBits, dataBits);\n    }\n\n    var headerAndDataBits = new BitArray();\n    headerAndDataBits.appendBitArray(headerBits); // Find \"length\" of main segment and write it\n\n    var numLetters = mode === Mode.BYTE ? dataBits.getSizeInBytes() : content.length;\n    this.appendLengthInfo(numLetters, version, mode, headerAndDataBits); // Put data together into the overall payload\n\n    headerAndDataBits.appendBitArray(dataBits);\n    var ecBlocks = version.getECBlocksForLevel(ecLevel);\n    var numDataBytes = version.getTotalCodewords() - ecBlocks.getTotalECCodewords(); // Terminate the bits properly.\n\n    this.terminateBits(numDataBytes, headerAndDataBits); // Interleave data bits with error correction code.\n\n    var finalBits = this.interleaveWithECBytes(headerAndDataBits, version.getTotalCodewords(), numDataBytes, ecBlocks.getNumBlocks());\n    var qrCode = new QRCode();\n    qrCode.setECLevel(ecLevel);\n    qrCode.setMode(mode);\n    qrCode.setVersion(version); //  Choose the mask pattern and set to \"qrCode\".\n\n    var dimension = version.getDimensionForVersion();\n    var matrix = new ByteMatrix(dimension, dimension);\n    var maskPattern = this.chooseMaskPattern(finalBits, ecLevel, version, matrix);\n    qrCode.setMaskPattern(maskPattern); // Build the matrix and set it to \"qrCode\".\n\n    MatrixUtil.buildMatrix(finalBits, ecLevel, version, maskPattern, matrix);\n    qrCode.setMatrix(matrix);\n    return qrCode;\n  };\n  /**\n   * Decides the smallest version of QR code that will contain all of the provided data.\n   *\n   * @throws WriterException if the data cannot fit in any version\n   */\n\n\n  Encoder.recommendVersion = function (ecLevel, mode, headerBits, dataBits) {\n    // Hard part: need to know version to know how many bits length takes. But need to know how many\n    // bits it takes to know version. First we take a guess at version by assuming version will be\n    // the minimum, 1:\n    var provisionalBitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, Version.getVersionForNumber(1));\n    var provisionalVersion = this.chooseVersion(provisionalBitsNeeded, ecLevel); // Use that guess to calculate the right version. I am still not sure this works in 100% of cases.\n\n    var bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, provisionalVersion);\n    return this.chooseVersion(bitsNeeded, ecLevel);\n  };\n\n  Encoder.calculateBitsNeeded = function (mode, headerBits, dataBits, version) {\n    return headerBits.getSize() + mode.getCharacterCountBits(version) + dataBits.getSize();\n  };\n  /**\n   * @return the code point of the table used in alphanumeric mode or\n   *  -1 if there is no corresponding code in the table.\n   */\n\n\n  Encoder.getAlphanumericCode = function (code\n  /*int*/\n  ) {\n    if (code < Encoder.ALPHANUMERIC_TABLE.length) {\n      return Encoder.ALPHANUMERIC_TABLE[code];\n    }\n\n    return -1;\n  }; // public static chooseMode(content: string): Mode {\n  //   return chooseMode(content, null);\n  // }\n\n  /**\n   * Choose the best mode by examining the content. Note that 'encoding' is used as a hint;\n   * if it is Shift_JIS, and the input is only double-byte Kanji, then we return {@link Mode#KANJI}.\n   */\n\n\n  Encoder.chooseMode = function (content, encoding) {\n    if (encoding === void 0) {\n      encoding = null;\n    }\n\n    if (CharacterSetECI.SJIS.getName() === encoding && this.isOnlyDoubleByteKanji(content)) {\n      // Choose Kanji mode if all input are double-byte characters\n      return Mode.KANJI;\n    }\n\n    var hasNumeric = false;\n    var hasAlphanumeric = false;\n\n    for (var i = 0, length_1 = content.length; i < length_1; ++i) {\n      var c = content.charAt(i);\n\n      if (Encoder.isDigit(c)) {\n        hasNumeric = true;\n      } else if (this.getAlphanumericCode(c.charCodeAt(0)) !== -1) {\n        hasAlphanumeric = true;\n      } else {\n        return Mode.BYTE;\n      }\n    }\n\n    if (hasAlphanumeric) {\n      return Mode.ALPHANUMERIC;\n    }\n\n    if (hasNumeric) {\n      return Mode.NUMERIC;\n    }\n\n    return Mode.BYTE;\n  };\n\n  Encoder.isOnlyDoubleByteKanji = function (content) {\n    var bytes;\n\n    try {\n      bytes = StringEncoding.encode(content, CharacterSetECI.SJIS); // content.getBytes(\"Shift_JIS\"))\n    } catch (ignored\n    /*: UnsupportedEncodingException*/\n    ) {\n      return false;\n    }\n\n    var length = bytes.length;\n\n    if (length % 2 !== 0) {\n      return false;\n    }\n\n    for (var i = 0; i < length; i += 2) {\n      var byte1 = bytes[i] & 0xFF;\n\n      if ((byte1 < 0x81 || byte1 > 0x9F) && (byte1 < 0xE0 || byte1 > 0xEB)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  Encoder.chooseMaskPattern = function (bits, ecLevel, version, matrix) {\n    var minPenalty = Number.MAX_SAFE_INTEGER; // Lower penalty is better.\n\n    var bestMaskPattern = -1; // We try all mask patterns to choose the best one.\n\n    for (var maskPattern = 0; maskPattern < QRCode.NUM_MASK_PATTERNS; maskPattern++) {\n      MatrixUtil.buildMatrix(bits, ecLevel, version, maskPattern, matrix);\n      var penalty = this.calculateMaskPenalty(matrix);\n\n      if (penalty < minPenalty) {\n        minPenalty = penalty;\n        bestMaskPattern = maskPattern;\n      }\n    }\n\n    return bestMaskPattern;\n  };\n\n  Encoder.chooseVersion = function (numInputBits\n  /*int*/\n  , ecLevel) {\n    for (var versionNum = 1; versionNum <= 40; versionNum++) {\n      var version = Version.getVersionForNumber(versionNum);\n\n      if (Encoder.willFit(numInputBits, version, ecLevel)) {\n        return version;\n      }\n    }\n\n    throw new WriterException('Data too big');\n  };\n  /**\n   * @return true if the number of input bits will fit in a code with the specified version and\n   * error correction level.\n   */\n\n\n  Encoder.willFit = function (numInputBits\n  /*int*/\n  , version, ecLevel) {\n    // In the following comments, we use numbers of Version 7-H.\n    // numBytes = 196\n    var numBytes = version.getTotalCodewords(); // getNumECBytes = 130\n\n    var ecBlocks = version.getECBlocksForLevel(ecLevel);\n    var numEcBytes = ecBlocks.getTotalECCodewords(); // getNumDataBytes = 196 - 130 = 66\n\n    var numDataBytes = numBytes - numEcBytes;\n    var totalInputBytes = (numInputBits + 7) / 8;\n    return numDataBytes >= totalInputBytes;\n  };\n  /**\n   * Terminate bits as described in 8.4.8 and 8.4.9 of JISX0510:2004 (p.24).\n   */\n\n\n  Encoder.terminateBits = function (numDataBytes\n  /*int*/\n  , bits) {\n    var capacity = numDataBytes * 8;\n\n    if (bits.getSize() > capacity) {\n      throw new WriterException('data bits cannot fit in the QR Code' + bits.getSize() + ' > ' + capacity);\n    }\n\n    for (var i = 0; i < 4 && bits.getSize() < capacity; ++i) {\n      bits.appendBit(false);\n    } // Append termination bits. See 8.4.8 of JISX0510:2004 (p.24) for details.\n    // If the last byte isn't 8-bit aligned, we'll add padding bits.\n\n\n    var numBitsInLastByte = bits.getSize() & 0x07;\n\n    if (numBitsInLastByte > 0) {\n      for (var i = numBitsInLastByte; i < 8; i++) {\n        bits.appendBit(false);\n      }\n    } // If we have more space, we'll fill the space with padding patterns defined in 8.4.9 (p.24).\n\n\n    var numPaddingBytes = numDataBytes - bits.getSizeInBytes();\n\n    for (var i = 0; i < numPaddingBytes; ++i) {\n      bits.appendBits((i & 0x01) === 0 ? 0xEC : 0x11, 8);\n    }\n\n    if (bits.getSize() !== capacity) {\n      throw new WriterException('Bits size does not equal capacity');\n    }\n  };\n  /**\n   * Get number of data bytes and number of error correction bytes for block id \"blockID\". Store\n   * the result in \"numDataBytesInBlock\", and \"numECBytesInBlock\". See table 12 in 8.5.1 of\n   * JISX0510:2004 (p.30)\n   */\n\n\n  Encoder.getNumDataBytesAndNumECBytesForBlockID = function (numTotalBytes\n  /*int*/\n  , numDataBytes\n  /*int*/\n  , numRSBlocks\n  /*int*/\n  , blockID\n  /*int*/\n  , numDataBytesInBlock, numECBytesInBlock) {\n    if (blockID >= numRSBlocks) {\n      throw new WriterException('Block ID too large');\n    } // numRsBlocksInGroup2 = 196 % 5 = 1\n\n\n    var numRsBlocksInGroup2 = numTotalBytes % numRSBlocks; // numRsBlocksInGroup1 = 5 - 1 = 4\n\n    var numRsBlocksInGroup1 = numRSBlocks - numRsBlocksInGroup2; // numTotalBytesInGroup1 = 196 / 5 = 39\n\n    var numTotalBytesInGroup1 = Math.floor(numTotalBytes / numRSBlocks); // numTotalBytesInGroup2 = 39 + 1 = 40\n\n    var numTotalBytesInGroup2 = numTotalBytesInGroup1 + 1; // numDataBytesInGroup1 = 66 / 5 = 13\n\n    var numDataBytesInGroup1 = Math.floor(numDataBytes / numRSBlocks); // numDataBytesInGroup2 = 13 + 1 = 14\n\n    var numDataBytesInGroup2 = numDataBytesInGroup1 + 1; // numEcBytesInGroup1 = 39 - 13 = 26\n\n    var numEcBytesInGroup1 = numTotalBytesInGroup1 - numDataBytesInGroup1; // numEcBytesInGroup2 = 40 - 14 = 26\n\n    var numEcBytesInGroup2 = numTotalBytesInGroup2 - numDataBytesInGroup2; // Sanity checks.\n    // 26 = 26\n\n    if (numEcBytesInGroup1 !== numEcBytesInGroup2) {\n      throw new WriterException('EC bytes mismatch');\n    } // 5 = 4 + 1.\n\n\n    if (numRSBlocks !== numRsBlocksInGroup1 + numRsBlocksInGroup2) {\n      throw new WriterException('RS blocks mismatch');\n    } // 196 = (13 + 26) * 4 + (14 + 26) * 1\n\n\n    if (numTotalBytes !== (numDataBytesInGroup1 + numEcBytesInGroup1) * numRsBlocksInGroup1 + (numDataBytesInGroup2 + numEcBytesInGroup2) * numRsBlocksInGroup2) {\n      throw new WriterException('Total bytes mismatch');\n    }\n\n    if (blockID < numRsBlocksInGroup1) {\n      numDataBytesInBlock[0] = numDataBytesInGroup1;\n      numECBytesInBlock[0] = numEcBytesInGroup1;\n    } else {\n      numDataBytesInBlock[0] = numDataBytesInGroup2;\n      numECBytesInBlock[0] = numEcBytesInGroup2;\n    }\n  };\n  /**\n   * Interleave \"bits\" with corresponding error correction bytes. On success, store the result in\n   * \"result\". The interleave rule is complicated. See 8.6 of JISX0510:2004 (p.37) for details.\n   */\n\n\n  Encoder.interleaveWithECBytes = function (bits, numTotalBytes\n  /*int*/\n  , numDataBytes\n  /*int*/\n  , numRSBlocks\n  /*int*/\n  ) {\n    var e_1, _a, e_2, _b; // \"bits\" must have \"getNumDataBytes\" bytes of data.\n\n\n    if (bits.getSizeInBytes() !== numDataBytes) {\n      throw new WriterException('Number of bits and data bytes does not match');\n    } // Step 1.  Divide data bytes into blocks and generate error correction bytes for them. We'll\n    // store the divided data bytes blocks and error correction bytes blocks into \"blocks\".\n\n\n    var dataBytesOffset = 0;\n    var maxNumDataBytes = 0;\n    var maxNumEcBytes = 0; // Since, we know the number of reedsolmon blocks, we can initialize the vector with the number.\n\n    var blocks = new Array(); // new Array<BlockPair>(numRSBlocks)\n\n    for (var i = 0; i < numRSBlocks; ++i) {\n      var numDataBytesInBlock = new Int32Array(1);\n      var numEcBytesInBlock = new Int32Array(1);\n      Encoder.getNumDataBytesAndNumECBytesForBlockID(numTotalBytes, numDataBytes, numRSBlocks, i, numDataBytesInBlock, numEcBytesInBlock);\n      var size = numDataBytesInBlock[0];\n      var dataBytes = new Uint8Array(size);\n      bits.toBytes(8 * dataBytesOffset, dataBytes, 0, size);\n      var ecBytes = Encoder.generateECBytes(dataBytes, numEcBytesInBlock[0]);\n      blocks.push(new BlockPair(dataBytes, ecBytes));\n      maxNumDataBytes = Math.max(maxNumDataBytes, size);\n      maxNumEcBytes = Math.max(maxNumEcBytes, ecBytes.length);\n      dataBytesOffset += numDataBytesInBlock[0];\n    }\n\n    if (numDataBytes !== dataBytesOffset) {\n      throw new WriterException('Data bytes does not match offset');\n    }\n\n    var result = new BitArray(); // First, place data blocks.\n\n    for (var i = 0; i < maxNumDataBytes; ++i) {\n      try {\n        for (var blocks_1 = (e_1 = void 0, __values(blocks)), blocks_1_1 = blocks_1.next(); !blocks_1_1.done; blocks_1_1 = blocks_1.next()) {\n          var block = blocks_1_1.value;\n          var dataBytes = block.getDataBytes();\n\n          if (i < dataBytes.length) {\n            result.appendBits(dataBytes[i], 8);\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (blocks_1_1 && !blocks_1_1.done && (_a = blocks_1.return)) _a.call(blocks_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    } // Then, place error correction blocks.\n\n\n    for (var i = 0; i < maxNumEcBytes; ++i) {\n      try {\n        for (var blocks_2 = (e_2 = void 0, __values(blocks)), blocks_2_1 = blocks_2.next(); !blocks_2_1.done; blocks_2_1 = blocks_2.next()) {\n          var block = blocks_2_1.value;\n          var ecBytes = block.getErrorCorrectionBytes();\n\n          if (i < ecBytes.length) {\n            result.appendBits(ecBytes[i], 8);\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (blocks_2_1 && !blocks_2_1.done && (_b = blocks_2.return)) _b.call(blocks_2);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }\n\n    if (numTotalBytes !== result.getSizeInBytes()) {\n      // Should be same.\n      throw new WriterException('Interleaving error: ' + numTotalBytes + ' and ' + result.getSizeInBytes() + ' differ.');\n    }\n\n    return result;\n  };\n\n  Encoder.generateECBytes = function (dataBytes, numEcBytesInBlock\n  /*int*/\n  ) {\n    var numDataBytes = dataBytes.length;\n    var toEncode = new Int32Array(numDataBytes + numEcBytesInBlock); // int[numDataBytes + numEcBytesInBlock]\n\n    for (var i = 0; i < numDataBytes; i++) {\n      toEncode[i] = dataBytes[i] & 0xFF;\n    }\n\n    new ReedSolomonEncoder(GenericGF.QR_CODE_FIELD_256).encode(toEncode, numEcBytesInBlock);\n    var ecBytes = new Uint8Array(numEcBytesInBlock);\n\n    for (var i = 0; i < numEcBytesInBlock; i++) {\n      ecBytes[i] =\n      /*(byte) */\n      toEncode[numDataBytes + i];\n    }\n\n    return ecBytes;\n  };\n  /**\n   * Append mode info. On success, store the result in \"bits\".\n   */\n\n\n  Encoder.appendModeInfo = function (mode, bits) {\n    bits.appendBits(mode.getBits(), 4);\n  };\n  /**\n   * Append length info. On success, store the result in \"bits\".\n   */\n\n\n  Encoder.appendLengthInfo = function (numLetters\n  /*int*/\n  , version, mode, bits) {\n    var numBits = mode.getCharacterCountBits(version);\n\n    if (numLetters >= 1 << numBits) {\n      throw new WriterException(numLetters + ' is bigger than ' + ((1 << numBits) - 1));\n    }\n\n    bits.appendBits(numLetters, numBits);\n  };\n  /**\n   * Append \"bytes\" in \"mode\" mode (encoding) into \"bits\". On success, store the result in \"bits\".\n   */\n\n\n  Encoder.appendBytes = function (content, mode, bits, encoding) {\n    switch (mode) {\n      case Mode.NUMERIC:\n        Encoder.appendNumericBytes(content, bits);\n        break;\n\n      case Mode.ALPHANUMERIC:\n        Encoder.appendAlphanumericBytes(content, bits);\n        break;\n\n      case Mode.BYTE:\n        Encoder.append8BitBytes(content, bits, encoding);\n        break;\n\n      case Mode.KANJI:\n        Encoder.appendKanjiBytes(content, bits);\n        break;\n\n      default:\n        throw new WriterException('Invalid mode: ' + mode);\n    }\n  };\n\n  Encoder.getDigit = function (singleCharacter) {\n    return singleCharacter.charCodeAt(0) - 48;\n  };\n\n  Encoder.isDigit = function (singleCharacter) {\n    var cn = Encoder.getDigit(singleCharacter);\n    return cn >= 0 && cn <= 9;\n  };\n\n  Encoder.appendNumericBytes = function (content, bits) {\n    var length = content.length;\n    var i = 0;\n\n    while (i < length) {\n      var num1 = Encoder.getDigit(content.charAt(i));\n\n      if (i + 2 < length) {\n        // Encode three numeric letters in ten bits.\n        var num2 = Encoder.getDigit(content.charAt(i + 1));\n        var num3 = Encoder.getDigit(content.charAt(i + 2));\n        bits.appendBits(num1 * 100 + num2 * 10 + num3, 10);\n        i += 3;\n      } else if (i + 1 < length) {\n        // Encode two numeric letters in seven bits.\n        var num2 = Encoder.getDigit(content.charAt(i + 1));\n        bits.appendBits(num1 * 10 + num2, 7);\n        i += 2;\n      } else {\n        // Encode one numeric letter in four bits.\n        bits.appendBits(num1, 4);\n        i++;\n      }\n    }\n  };\n\n  Encoder.appendAlphanumericBytes = function (content, bits) {\n    var length = content.length;\n    var i = 0;\n\n    while (i < length) {\n      var code1 = Encoder.getAlphanumericCode(content.charCodeAt(i));\n\n      if (code1 === -1) {\n        throw new WriterException();\n      }\n\n      if (i + 1 < length) {\n        var code2 = Encoder.getAlphanumericCode(content.charCodeAt(i + 1));\n\n        if (code2 === -1) {\n          throw new WriterException();\n        } // Encode two alphanumeric letters in 11 bits.\n\n\n        bits.appendBits(code1 * 45 + code2, 11);\n        i += 2;\n      } else {\n        // Encode one alphanumeric letter in six bits.\n        bits.appendBits(code1, 6);\n        i++;\n      }\n    }\n  };\n\n  Encoder.append8BitBytes = function (content, bits, encoding) {\n    var bytes;\n\n    try {\n      bytes = StringEncoding.encode(content, encoding);\n    } catch (uee\n    /*: UnsupportedEncodingException*/\n    ) {\n      throw new WriterException(uee);\n    }\n\n    for (var i = 0, length_2 = bytes.length; i !== length_2; i++) {\n      var b = bytes[i];\n      bits.appendBits(b, 8);\n    }\n  };\n  /**\n   * @throws WriterException\n   */\n\n\n  Encoder.appendKanjiBytes = function (content, bits) {\n    var bytes;\n\n    try {\n      bytes = StringEncoding.encode(content, CharacterSetECI.SJIS);\n    } catch (uee\n    /*: UnsupportedEncodingException*/\n    ) {\n      throw new WriterException(uee);\n    }\n\n    var length = bytes.length;\n\n    for (var i = 0; i < length; i += 2) {\n      var byte1 = bytes[i] & 0xFF;\n      var byte2 = bytes[i + 1] & 0xFF;\n      var code = byte1 << 8 & 0xFFFFFFFF | byte2;\n      var subtracted = -1;\n\n      if (code >= 0x8140 && code <= 0x9ffc) {\n        subtracted = code - 0x8140;\n      } else if (code >= 0xe040 && code <= 0xebbf) {\n        subtracted = code - 0xc140;\n      }\n\n      if (subtracted === -1) {\n        throw new WriterException('Invalid byte sequence');\n      }\n\n      var encoded = (subtracted >> 8) * 0xc0 + (subtracted & 0xff);\n      bits.appendBits(encoded, 13);\n    }\n  };\n\n  Encoder.appendECI = function (eci, bits) {\n    bits.appendBits(Mode.ECI.getBits(), 4); // This is correct for values up to 127, which is all we need now.\n\n    bits.appendBits(eci.getValue(), 8);\n  }; // The original table is defined in the table 5 of JISX0510:2004 (p.19).\n\n\n  Encoder.ALPHANUMERIC_TABLE = Int32Array.from([-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 36, -1, -1, -1, 37, 38, -1, -1, -1, -1, 39, 40, -1, 41, 42, 43, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 44, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1]);\n  Encoder.DEFAULT_BYTE_MODE_ENCODING = CharacterSetECI.UTF8.getName(); // \"ISO-8859-1\"\n\n  return Encoder;\n}();\n\nexport default Encoder; //# sourceMappingURL=Encoder.js.map","map":null,"metadata":{},"sourceType":"module"}