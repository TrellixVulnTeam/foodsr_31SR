{"ast":null,"code":"/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n/*namespace com.google.zxing.qrcode.encoder {*/\n\n/*import java.util.Arrays;*/\n\n\nimport Arrays from '../../util/Arrays';\nimport StringBuilder from '../../util/StringBuilder';\n/**\n * JAVAPORT: The original code was a 2D array of ints, but since it only ever gets assigned\n * -1, 0, and 1, I'm going to use less memory and go with bytes.\n *\n * @author dswitkin@google.com (Daniel Switkin)\n */\n\nvar ByteMatrix = function () {\n  function ByteMatrix(width\n  /*int*/\n  , height\n  /*int*/\n  ) {\n    this.width = width;\n    this.height = height;\n    var bytes = new Array(height); // [height][width]\n\n    for (var i = 0; i !== height; i++) {\n      bytes[i] = new Uint8Array(width);\n    }\n\n    this.bytes = bytes;\n  }\n\n  ByteMatrix.prototype.getHeight = function () {\n    return this.height;\n  };\n\n  ByteMatrix.prototype.getWidth = function () {\n    return this.width;\n  };\n\n  ByteMatrix.prototype.get = function (x\n  /*int*/\n  , y\n  /*int*/\n  ) {\n    return this.bytes[y][x];\n  };\n  /**\n   * @return an internal representation as bytes, in row-major order. array[y][x] represents point (x,y)\n   */\n\n\n  ByteMatrix.prototype.getArray = function () {\n    return this.bytes;\n  }; // TYPESCRIPTPORT: preffer to let two methods instead of override to avoid type comparison inside\n\n\n  ByteMatrix.prototype.setNumber = function (x\n  /*int*/\n  , y\n  /*int*/\n  , value\n  /*byte|int*/\n  ) {\n    this.bytes[y][x] = value;\n  }; // public set(x: number /*int*/, y: number /*int*/, value: number /*int*/): void {\n  //   bytes[y][x] = (byte) value\n  // }\n\n\n  ByteMatrix.prototype.setBoolean = function (x\n  /*int*/\n  , y\n  /*int*/\n  , value) {\n    this.bytes[y][x] = value ? 1 : 0;\n  };\n\n  ByteMatrix.prototype.clear = function (value\n  /*byte*/\n  ) {\n    var e_1, _a;\n\n    try {\n      for (var _b = __values(this.bytes), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var aByte = _c.value;\n        Arrays.fill(aByte, value);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n\n  ByteMatrix.prototype.equals = function (o) {\n    if (!(o instanceof ByteMatrix)) {\n      return false;\n    }\n\n    var other = o;\n\n    if (this.width !== other.width) {\n      return false;\n    }\n\n    if (this.height !== other.height) {\n      return false;\n    }\n\n    for (var y = 0, height = this.height; y < height; ++y) {\n      var bytesY = this.bytes[y];\n      var otherBytesY = other.bytes[y];\n\n      for (var x = 0, width = this.width; x < width; ++x) {\n        if (bytesY[x] !== otherBytesY[x]) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n  /*@Override*/\n\n\n  ByteMatrix.prototype.toString = function () {\n    var result = new StringBuilder(); // (2 * width * height + 2)\n\n    for (var y = 0, height = this.height; y < height; ++y) {\n      var bytesY = this.bytes[y];\n\n      for (var x = 0, width = this.width; x < width; ++x) {\n        switch (bytesY[x]) {\n          case 0:\n            result.append(' 0');\n            break;\n\n          case 1:\n            result.append(' 1');\n            break;\n\n          default:\n            result.append('  ');\n            break;\n        }\n      }\n\n      result.append('\\n');\n    }\n\n    return result.toString();\n  };\n\n  return ByteMatrix;\n}();\n\nexport default ByteMatrix; //# sourceMappingURL=ByteMatrix.js.map","map":null,"metadata":{},"sourceType":"module"}