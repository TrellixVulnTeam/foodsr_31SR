{"ast":null,"code":"import { EncodeHintType, IllegalArgumentException, IllegalStateException, QRCodeDecoderErrorCorrectionLevel, QRCodeEncoder } from '@zxing/library';\nvar svgNs = 'http://www.w3.org/2000/svg';\n/**/\n\nvar BrowserCodeSvgWriter = function () {\n  /**\n   * Constructs. ðŸ˜‰\n   */\n  function BrowserCodeSvgWriter(containerElement) {\n    if (typeof containerElement === 'string') {\n      var container = document.getElementById(containerElement);\n\n      if (!container) {\n        throw new Error(\"Could not find a Container element with '\" + containerElement + \"'.\");\n      }\n\n      this.containerElement = container;\n    } else {\n      this.containerElement = containerElement;\n    }\n  }\n  /**\n   * Writes the QR code to a SVG and renders it in the container.\n   */\n\n\n  BrowserCodeSvgWriter.prototype.write = function (contents, width, height, hints) {\n    if (contents.length === 0) {\n      throw new IllegalArgumentException('Found empty contents');\n    }\n\n    if (width < 0 || height < 0) {\n      throw new IllegalArgumentException('Requested dimensions are too small: ' + width + 'x' + height);\n    }\n\n    var quietZone = hints && hints.get(EncodeHintType.MARGIN) !== undefined ? Number.parseInt(hints.get(EncodeHintType.MARGIN).toString(), 10) : BrowserCodeSvgWriter.QUIET_ZONE_SIZE;\n    var code = this.encode(hints, contents);\n    return this.renderResult(code, width, height, quietZone);\n  };\n  /**\n   * Creates a SVG element.\n   */\n\n\n  BrowserCodeSvgWriter.prototype.createSVGElement = function (w, h) {\n    var el = document.createElementNS(BrowserCodeSvgWriter.SVG_NS, 'svg');\n    el.setAttributeNS(svgNs, 'width', h.toString());\n    el.setAttributeNS(svgNs, 'height', w.toString());\n    return el;\n  };\n  /**\n   * Creates a SVG rect.\n   */\n\n\n  BrowserCodeSvgWriter.prototype.createSvgPathPlaceholderElement = function (w, h) {\n    var el = document.createElementNS(BrowserCodeSvgWriter.SVG_NS, 'path');\n    el.setAttributeNS(svgNs, 'd', \"M0 0h\" + w + \"v\" + h + \"H0z\");\n    el.setAttributeNS(svgNs, 'fill', 'none');\n    return el;\n  };\n  /**\n   * Creates a SVG rect.\n   */\n\n\n  BrowserCodeSvgWriter.prototype.createSvgRectElement = function (x, y, w, h) {\n    var el = document.createElementNS(BrowserCodeSvgWriter.SVG_NS, 'rect');\n    el.setAttributeNS(svgNs, 'x', x.toString());\n    el.setAttributeNS(svgNs, 'y', y.toString());\n    el.setAttributeNS(svgNs, 'height', w.toString());\n    el.setAttributeNS(svgNs, 'width', h.toString());\n    el.setAttributeNS(svgNs, 'fill', '#000000');\n    return el;\n  };\n  /**\n   * Encodes the content to a Barcode type.\n   */\n\n\n  BrowserCodeSvgWriter.prototype.encode = function (hints, contents) {\n    var errorCorrectionLevel = QRCodeDecoderErrorCorrectionLevel.L;\n\n    if (hints && hints.get(EncodeHintType.ERROR_CORRECTION) !== undefined) {\n      var correctionStr = hints.get(EncodeHintType.ERROR_CORRECTION).toString();\n      errorCorrectionLevel = QRCodeDecoderErrorCorrectionLevel.fromString(correctionStr);\n    }\n\n    var code = QRCodeEncoder.encode(contents, errorCorrectionLevel, hints);\n    return code;\n  };\n  /**\n   * Renders the SVG in the container.\n   *\n   * @note the input matrix uses 0 == white, 1 == black. The output matrix\n   *  uses 0 == black, 255 == white (i.e. an 8 bit greyscale bitmap).\n   */\n\n\n  BrowserCodeSvgWriter.prototype.renderResult = function (code, width\n  /*int*/\n  , height\n  /*int*/\n  , quietZone\n  /*int*/\n  ) {\n    // if (this.format && format != this.format) {\n    //   throw new IllegalArgumentException(\"Can only encode QR_CODE, but got \" + format)\n    // }\n    var input = code.getMatrix();\n\n    if (input === null) {\n      throw new IllegalStateException();\n    }\n\n    var inputWidth = input.getWidth();\n    var inputHeight = input.getHeight();\n    var qrWidth = inputWidth + quietZone * 2;\n    var qrHeight = inputHeight + quietZone * 2;\n    var outputWidth = Math.max(width, qrWidth);\n    var outputHeight = Math.max(height, qrHeight);\n    var multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight)); // Padding includes both the quiet zone and the extra white pixels to accommodate the requested\n    // dimensions. For example, if input is 25x25 the QR will be 33x33 including the quiet zone.\n    // If the requested size is 200x160, the multiple will be 4, for a QR of 132x132. These will\n    // handle all the padding from 100x100 (the actual QR) up to 200x160.\n\n    var leftPadding = Math.floor((outputWidth - inputWidth * multiple) / 2);\n    var topPadding = Math.floor((outputHeight - inputHeight * multiple) / 2);\n    var svgElement = this.createSVGElement(outputWidth, outputHeight);\n    var placeholder = this.createSvgPathPlaceholderElement(width, height);\n    svgElement.appendChild(placeholder);\n    this.containerElement.appendChild(svgElement); // 2D loop\n\n    for (var inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {\n      // Write the contents of this row of the barcode\n      for (var inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {\n        if (input.get(inputX, inputY) === 1) {\n          var svgRectElement = this.createSvgRectElement(outputX, outputY, multiple, multiple);\n          svgElement.appendChild(svgRectElement);\n        }\n      }\n    }\n\n    return svgElement;\n  };\n  /**\n   * Default quiet zone in pixels.\n   */\n\n\n  BrowserCodeSvgWriter.QUIET_ZONE_SIZE = 4;\n  /**\n   * SVG markup NameSpace\n   */\n\n  BrowserCodeSvgWriter.SVG_NS = 'http://www.w3.org/2000/svg';\n  return BrowserCodeSvgWriter;\n}();\n\nexport { BrowserCodeSvgWriter }; //# sourceMappingURL=BrowserCodeSvgWriter.js.map","map":null,"metadata":{},"sourceType":"module"}